diff --git a/pypy-5.0.1-src/pypy/module/_cffi_backend/cdataobj.py b/pypy-5.0.1-src/pypy/module/_cffi_backend/cdataobj.py
index 6c7c9ab..e8a4c68 100644
--- a/pypy-5.0.1-src/pypy/module/_cffi_backend/cdataobj.py
+++ b/pypy-5.0.1-src/pypy/module/_cffi_backend/cdataobj.py
@@ -109,15 +109,16 @@ class W_CData(W_Root):
             if not isinstance(w_other, W_CData):
                 return space.w_NotImplemented
 
-            with self as ptr1, w_other as ptr2:
-                if requires_ordering:
-                    if (isinstance(self.ctype, W_CTypePrimitive) or
-                        isinstance(w_other.ctype, W_CTypePrimitive)):
-                        raise OperationError(space.w_TypeError, space.wrap(
-                            "cannot do comparison on a primitive cdata"))
-                    ptr1 = rffi.cast(lltype.Unsigned, ptr1)
-                    ptr2 = rffi.cast(lltype.Unsigned, ptr2)
-                result = op(ptr1, ptr2)
+            with self as ptr1:
+                with w_other as ptr2:
+                    if requires_ordering:
+                        if (isinstance(self.ctype, W_CTypePrimitive) or
+                            isinstance(w_other.ctype, W_CTypePrimitive)):
+                            raise OperationError(space.w_TypeError, space.wrap(
+                                "cannot do comparison on a primitive cdata"))
+                        ptr1 = rffi.cast(lltype.Unsigned, ptr1)
+                        ptr2 = rffi.cast(lltype.Unsigned, ptr2)
+                    result = op(ptr1, ptr2)
             return space.newbool(result)
         #
         return func_with_new_name(_cmp, name)
@@ -290,9 +291,10 @@ class W_CData(W_Root):
             itemsize = ct.ctitem.size
             if itemsize <= 0:
                 itemsize = 1
-            with self as ptr1, w_other as ptr2:
-                diff = (rffi.cast(lltype.Signed, ptr1) -
-                        rffi.cast(lltype.Signed, ptr2)) // itemsize
+            with self as ptr1:
+                with w_other as ptr2:
+                    diff = (rffi.cast(lltype.Signed, ptr1) -
+                            rffi.cast(lltype.Signed, ptr2)) // itemsize
             return space.wrap(diff)
         #
         return self._add_or_sub(w_other, -1)
diff --git a/pypy-5.0.1-src/pypy/module/micronumpy/selection.py b/pypy-5.0.1-src/pypy/module/micronumpy/selection.py
index 30b8f57..d4d2628 100644
--- a/pypy-5.0.1-src/pypy/module/micronumpy/selection.py
+++ b/pypy-5.0.1-src/pypy/module/micronumpy/selection.py
@@ -134,37 +134,38 @@ def make_argsort_function(space, itemtype, comp_type, count=1):
         # create array of indexes
         dtype = descriptor.get_dtype_cache(space).w_longdtype
         index_arr = W_NDimArray.from_shape(space, arr.get_shape(), dtype)
-        with index_arr.implementation as storage, arr as arr_storage:
-            if len(arr.get_shape()) == 1:
-                for i in range(arr.get_size()):
-                    raw_storage_setitem(storage, i * INT_SIZE, i)
-                r = Repr(INT_SIZE, arr.strides[0], arr.get_size(), arr_storage,
-                         storage, 0, arr.start)
-                ArgSort(r).sort()
-            else:
-                shape = arr.get_shape()
-                if axis < 0:
-                    axis = len(shape) + axis
-                if axis < 0 or axis >= len(shape):
-                    raise oefmt(space.w_IndexError, "Wrong axis %d", axis)
-                arr_iter = AllButAxisIter(arr, axis)
-                arr_state = arr_iter.reset()
-                index_impl = index_arr.implementation
-                index_iter = AllButAxisIter(index_impl, axis)
-                index_state = index_iter.reset()
-                stride_size = arr.strides[axis]
-                index_stride_size = index_impl.strides[axis]
-                axis_size = arr.shape[axis]
-                while not arr_iter.done(arr_state):
-                    for i in range(axis_size):
-                        raw_storage_setitem(storage, i * index_stride_size +
-                                            index_state.offset, i)
-                    r = Repr(index_stride_size, stride_size, axis_size,
-                         arr_storage, storage, index_state.offset, arr_state.offset)
+        with index_arr.implementation as storage:
+            with arr as arr_storage:
+                if len(arr.get_shape()) == 1:
+                    for i in range(arr.get_size()):
+                        raw_storage_setitem(storage, i * INT_SIZE, i)
+                    r = Repr(INT_SIZE, arr.strides[0], arr.get_size(), arr_storage,
+                             storage, 0, arr.start)
                     ArgSort(r).sort()
-                    arr_state = arr_iter.next(arr_state)
-                    index_state = index_iter.next(index_state)
-            return index_arr
+                else:
+                    shape = arr.get_shape()
+                    if axis < 0:
+                        axis = len(shape) + axis
+                    if axis < 0 or axis >= len(shape):
+                        raise oefmt(space.w_IndexError, "Wrong axis %d", axis)
+                    arr_iter = AllButAxisIter(arr, axis)
+                    arr_state = arr_iter.reset()
+                    index_impl = index_arr.implementation
+                    index_iter = AllButAxisIter(index_impl, axis)
+                    index_state = index_iter.reset()
+                    stride_size = arr.strides[axis]
+                    index_stride_size = index_impl.strides[axis]
+                    axis_size = arr.shape[axis]
+                    while not arr_iter.done(arr_state):
+                        for i in range(axis_size):
+                            raw_storage_setitem(storage, i * index_stride_size +
+                                                index_state.offset, i)
+                        r = Repr(index_stride_size, stride_size, axis_size,
+                             arr_storage, storage, index_state.offset, arr_state.offset)
+                        ArgSort(r).sort()
+                        arr_state = arr_iter.next(arr_state)
+                        index_state = index_iter.next(index_state)
+                return index_arr
 
     return argsort
 
diff --git a/pypy-5.0.1-src/pypy/module/micronumpy/types.py b/pypy-5.0.1-src/pypy/module/micronumpy/types.py
index f1f9e8a..fae6168 100644
--- a/pypy-5.0.1-src/pypy/module/micronumpy/types.py
+++ b/pypy-5.0.1-src/pypy/module/micronumpy/types.py
@@ -2428,9 +2428,10 @@ class VoidType(FlexibleType):
     def store(self, arr, i, offset, box, native):
         assert isinstance(box, boxes.W_VoidBox)
         assert box.dtype is box.arr.dtype
-        with arr as arr_storage, box.arr as box_storage:
-            for k in range(box.arr.dtype.elsize):
-                arr_storage[i + k + offset] = box_storage[k + box.ofs]
+        with arr as arr_storage:
+            with box.arr as box_storage:
+                for k in range(box.arr.dtype.elsize):
+                    arr_storage[i + k + offset] = box_storage[k + box.ofs]
 
     def readarray(self, arr, i, offset, dtype=None):
         from pypy.module.micronumpy.base import W_NDimArray
@@ -2588,10 +2589,11 @@ class RecordType(FlexibleType):
         s1 = v1.dtype.elsize
         s2 = v2.dtype.elsize
         assert s1 == s2
-        with v1.arr as v1_storage, v2.arr as v2_storage:
-            for i in range(s1):
-                if v1_storage[v1.ofs + i] != v2_storage[v2.ofs + i]:
-                    return False
+        with v1.arr as v1_storage:
+            with v2.arr as v2_storage:
+                for i in range(s1):
+                    if v1_storage[v1.ofs + i] != v2_storage[v2.ofs + i]:
+                        return False
         return True
 
     def ne(self, v1, v2):
diff --git a/pypy-5.0.1-src/rpython/annotator/bookkeeper.py b/pypy-5.0.1-src/rpython/annotator/bookkeeper.py
index 4731c3a..f8fa461 100644
--- a/pypy-5.0.1-src/rpython/annotator/bookkeeper.py
+++ b/pypy-5.0.1-src/rpython/annotator/bookkeeper.py
@@ -168,7 +168,7 @@ class Bookkeeper(object):
         return desc.getuniqueclassdef()
 
     def new_exception(self, exc_classes):
-        clsdefs = {self.getuniqueclassdef(cls) for cls in exc_classes}
+        clsdefs = set([self.getuniqueclassdef(cls) for cls in exc_classes])
         return SomeException(clsdefs)
 
     def getlistdef(self, **flags_if_new):
diff --git a/pypy-5.0.1-src/rpython/annotator/model.py b/pypy-5.0.1-src/rpython/annotator/model.py
index f498ffc..161ea33 100644
--- a/pypy-5.0.1-src/rpython/annotator/model.py
+++ b/pypy-5.0.1-src/rpython/annotator/model.py
@@ -495,7 +495,7 @@ class SomeException(SomeObject):
 
 @intersection.register(SomeException, SomeInstance)
 def intersection_Exception_Instance(s_exc, s_inst):
-    classdefs = {c for c in s_exc.classdefs if c.issubclass(s_inst.classdef)}
+    classdefs = set([c for c in s_exc.classdefs if c.issubclass(s_inst.classdef)])
     if classdefs:
         return SomeException(classdefs)
     else:
@@ -507,8 +507,8 @@ def intersection_Exception_Instance(s_inst, s_exc):
 
 @difference.register(SomeException, SomeInstance)
 def difference_Exception_Instance(s_exc, s_inst):
-    classdefs = {c for c in s_exc.classdefs
-        if not c.issubclass(s_inst.classdef)}
+    classdefs = set([c for c in s_exc.classdefs
+        if not c.issubclass(s_inst.classdef)])
     if classdefs:
         return SomeException(classdefs)
     else:
diff --git a/pypy-5.0.1-src/rpython/translator/backendopt/malloc.py b/pypy-5.0.1-src/rpython/translator/backendopt/malloc.py
index bfbdd4d..1fea680 100644
--- a/pypy-5.0.1-src/rpython/translator/backendopt/malloc.py
+++ b/pypy-5.0.1-src/rpython/translator/backendopt/malloc.py
@@ -10,7 +10,7 @@ class LifeTime:
 
     def __init__(self, (block, var)):
         assert isinstance(var, Variable)
-        self.variables = {(block, var)}
+        self.variables = set([(block, var)])
         self.creationpoints = set()   # set of ("type of creation point", ...)
         self.usepoints = set()        # set of ("type of use point",      ...)
 
@@ -293,7 +293,7 @@ class BaseMallocRemover(object):
                 if self.check_malloc(op) and op.result in vars:
                     vars_created_here.append(op.result)
             for var in vars_created_here:
-                self.flowin(block, count, {var}, newvarsmap=None)
+                self.flowin(block, count, set([var]), newvarsmap=None)
 
         return count[0]
 
diff --git a/pypy-5.0.1-src/rpython/translator/backendopt/storesink.py b/pypy-5.0.1-src/rpython/translator/backendopt/storesink.py
index 8a336f8..507147f 100644
--- a/pypy-5.0.1-src/rpython/translator/backendopt/storesink.py
+++ b/pypy-5.0.1-src/rpython/translator/backendopt/storesink.py
@@ -49,7 +49,9 @@ def _translate_cache(cache, link):
     if link.target.operations == (): # exit or except block:
         return {}
     block = link.target
-    local_versions = {var1: var2 for var1, var2 in zip(link.args, block.inputargs)}
+    local_versions = {}
+    for var1, var2 in zip(link.args, block.inputargs):
+        local_versions[var1] = var2
     def _translate_arg(arg):
         if isinstance(arg, Variable):
             res = local_versions.get(arg, None)
